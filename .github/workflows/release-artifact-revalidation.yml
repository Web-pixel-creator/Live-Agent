name: Release Artifact Revalidation

on:
  workflow_dispatch:
    inputs:
      source_run_id:
        description: Optional source workflow run ID containing release artifacts
        required: false
        type: string
      artifact_name:
        description: Optional artifact bundle name (auto-detected if omitted)
        required: false
        type: string
      perf_gate_mode:
        description: Perf gate mode for artifact-only revalidation (auto/with_perf/without_perf)
        required: false
        default: auto
        type: choice
        options:
          - auto
          - with_perf
          - without_perf
      strict_final_run:
        description: Enforce strict artifact gate (scenario retries must remain zero)
        required: false
        default: false
        type: boolean
      github_api_max_attempts:
        description: Max retry attempts for GitHub API and artifact download operations
        required: false
        default: "3"
        type: string
      github_api_retry_backoff_ms:
        description: Linear retry backoff base in milliseconds for GitHub API/download operations
        required: false
        default: "1200"
        type: string
      max_source_run_age_hours:
        description: Maximum allowed age (hours) for selected source run (0 disables age guard)
        required: false
        default: "168"
        type: string
      allow_any_source_branch:
        description: Allow source runs from branches outside main/master
        required: false
        default: false
        type: boolean

jobs:
  release-artifact-revalidation:
    runs-on: windows-latest
    timeout-minutes: 30
    permissions:
      contents: read
      actions: read
    concurrency:
      group: release-artifact-revalidation-${{ github.ref }}
      cancel-in-progress: true

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 24
          cache: npm

      - name: Resolve Source Run and Artifact
        id: resolve_source
        uses: actions/github-script@v7
        with:
          script: |
            const sourceRunIdRaw = core.getInput("source_run_id").trim();
            const artifactNameRaw = core.getInput("artifact_name").trim();
            const githubApiMaxAttemptsRaw = core.getInput("github_api_max_attempts").trim();
            const githubApiRetryBackoffMsRaw = core.getInput("github_api_retry_backoff_ms").trim();
            const maxSourceRunAgeHoursRaw = core.getInput("max_source_run_age_hours").trim();
            const allowAnySourceBranchRaw = core.getInput("allow_any_source_branch").trim();
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const githubApiMaxAttempts = Number(githubApiMaxAttemptsRaw || "3");
            const githubApiRetryBackoffMs = Number(githubApiRetryBackoffMsRaw || "1200");
            const maxSourceRunAgeHours = Number(maxSourceRunAgeHoursRaw || "168");
            const allowAnySourceBranch = (allowAnySourceBranchRaw || "false").toLowerCase() === "true";
            const allowedBranches = new Set(["main", "master"]);

            if (!Number.isInteger(githubApiMaxAttempts) || githubApiMaxAttempts < 1) {
              core.setFailed(`Invalid github_api_max_attempts: ${githubApiMaxAttemptsRaw}. Expected integer >= 1.`);
              return;
            }
            if (!Number.isInteger(githubApiRetryBackoffMs) || githubApiRetryBackoffMs < 0) {
              core.setFailed(
                `Invalid github_api_retry_backoff_ms: ${githubApiRetryBackoffMsRaw}. Expected integer >= 0.`
              );
              return;
            }
            if (!Number.isInteger(maxSourceRunAgeHours) || maxSourceRunAgeHours < 0) {
              core.setFailed(
                `Invalid max_source_run_age_hours: ${maxSourceRunAgeHoursRaw}. Expected integer >= 0.`
              );
              return;
            }

            const retryableStatuses = new Set([408, 429, 500, 502, 503, 504]);
            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
            const withRetry = async (operationName, operation) => {
              for (let attempt = 1; attempt <= githubApiMaxAttempts; attempt += 1) {
                try {
                  return await operation();
                } catch (error) {
                  const status = Number(error?.status ?? error?.response?.status ?? 0);
                  const retryable = status === 0 || retryableStatuses.has(status);
                  if (attempt >= githubApiMaxAttempts || !retryable) {
                    throw error;
                  }
                  const delayMs = githubApiRetryBackoffMs * attempt;
                  core.warning(
                    `${operationName} failed (attempt ${attempt}/${githubApiMaxAttempts}, status=${status || "n/a"}). Retrying in ${delayMs}ms.`
                  );
                  if (delayMs > 0) {
                    await sleep(delayMs);
                  }
                }
              }
              throw new Error(`Retry loop exited unexpectedly for operation: ${operationName}`);
            };

            let resolvedRunId = sourceRunIdRaw || null;
            let resolvedRunMeta = null;
            if (!resolvedRunId) {
              const candidates = [];
              const workflowIds = ["demo-e2e.yml", "release-strict-final.yml"];
              for (const workflowId of workflowIds) {
                const response = await withRetry(`listWorkflowRuns:${workflowId}`, () =>
                  github.rest.actions.listWorkflowRuns({
                    owner,
                    repo,
                    workflow_id: workflowId,
                    status: "completed",
                    per_page: 20
                  })
                );

                for (const run of response.data.workflow_runs || []) {
                  if (run.conclusion !== "success") {
                    continue;
                  }
                  if (!allowAnySourceBranch && run.head_branch !== "main" && run.head_branch !== "master") {
                    continue;
                  }
                  candidates.push({
                    runId: Number(run.id),
                    updatedAt: run.updated_at || run.created_at || "",
                    workflowId,
                    headBranch: String(run.head_branch || ""),
                    headSha: String(run.head_sha || ""),
                    conclusion: String(run.conclusion || "")
                  });
                }
              }

              if (candidates.length === 0) {
                core.setFailed("No successful main/master runs found for demo-e2e.yml or release-strict-final.yml.");
                return;
              }

              candidates.sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());
              const latest = candidates[0];
              resolvedRunId = String(latest.runId);
              resolvedRunMeta = latest;
              core.info(`Auto-selected run ${resolvedRunId} from ${latest.workflowId}`);
            }

            const parsedRunId = Number(resolvedRunId);
            if (!Number.isFinite(parsedRunId) || parsedRunId <= 0) {
              core.setFailed(`Invalid run id: ${resolvedRunId}`);
              return;
            }

            if (!resolvedRunMeta) {
              const runResponse = await withRetry(`getWorkflowRun:${parsedRunId}`, () =>
                github.rest.actions.getWorkflowRun({
                  owner,
                  repo,
                  run_id: parsedRunId
                })
              );
              const run = runResponse.data;
              resolvedRunMeta = {
                runId: Number(run.id || parsedRunId),
                updatedAt: run.updated_at || run.created_at || "",
                workflowId: String(run.path || run.name || "unknown"),
                headBranch: String(run.head_branch || ""),
                headSha: String(run.head_sha || ""),
                conclusion: String(run.conclusion || "")
              };
            }

            if (resolvedRunMeta.conclusion !== "success") {
              core.setFailed(
                `Run ${parsedRunId} conclusion is '${resolvedRunMeta.conclusion || "unknown"}'; expected success.`
              );
              return;
            }

            if (!resolvedRunMeta.headBranch) {
              core.setFailed(`Run ${parsedRunId} is missing head_branch metadata.`);
              return;
            }

            if (!allowAnySourceBranch && !allowedBranches.has(resolvedRunMeta.headBranch)) {
              core.setFailed(
                `Run ${parsedRunId} branch '${resolvedRunMeta.headBranch}' is not allowed. Allowed branches: main, master.`
              );
              return;
            }

            const updatedAtMs = Date.parse(resolvedRunMeta.updatedAt);
            if (!Number.isFinite(updatedAtMs)) {
              core.setFailed(
                `Run ${parsedRunId} has invalid updated timestamp '${resolvedRunMeta.updatedAt || "missing"}'.`
              );
              return;
            }

            const runAgeHours = Math.max(0, (Date.now() - updatedAtMs) / 3_600_000);
            if (maxSourceRunAgeHours > 0 && runAgeHours > maxSourceRunAgeHours) {
              core.setFailed(
                `Run ${parsedRunId} is too old (${runAgeHours.toFixed(2)}h > ${maxSourceRunAgeHours}h).`
              );
              return;
            }

            const runAgeHoursRounded = Number(runAgeHours.toFixed(2));
            const sourceHeadSha = resolvedRunMeta.headSha || "";
            const sourceHeadShaShort = sourceHeadSha.length > 12 ? sourceHeadSha.slice(0, 12) : sourceHeadSha || "unknown";

            const artifactsResponse = await withRetry(`listWorkflowRunArtifacts:${parsedRunId}`, () =>
              github.rest.actions.listWorkflowRunArtifacts({
                owner,
                repo,
                run_id: parsedRunId,
                per_page: 100
              })
            );

            const availableArtifacts = (artifactsResponse.data.artifacts || []).filter((artifact) => !artifact.expired);
            let resolvedArtifact = null;

            if (artifactNameRaw) {
              resolvedArtifact = availableArtifacts.find((artifact) => artifact.name === artifactNameRaw) || null;
              if (!resolvedArtifact) {
                const availableNames = availableArtifacts.map((artifact) => artifact.name);
                core.setFailed(
                  `Artifact '${artifactNameRaw}' not found in run ${parsedRunId}. Available: ${availableNames.join(", ")}`
                );
                return;
              }
            } else {
              const preferredOrder = [
                "release-strict-final-artifacts",
                "demo-e2e-artifacts",
                "pr-quality-artifacts"
              ];
              resolvedArtifact =
                preferredOrder
                  .map((name) => availableArtifacts.find((artifact) => artifact.name === name) || null)
                  .find((artifact) => artifact !== null) || null;

              if (!resolvedArtifact) {
                const availableNames = availableArtifacts.map((artifact) => artifact.name);
                core.setFailed(
                  `No supported artifact bundle found in run ${parsedRunId}. Available: ${availableNames.join(", ")}`
                );
                return;
              }
            }

            core.setOutput("run_id", String(parsedRunId));
            core.setOutput("artifact_name", resolvedArtifact.name);
            core.setOutput("artifact_id", String(resolvedArtifact.id));
            core.setOutput("github_api_max_attempts", String(githubApiMaxAttempts));
            core.setOutput("github_api_retry_backoff_ms", String(githubApiRetryBackoffMs));
            core.setOutput("source_run_workflow", String(resolvedRunMeta.workflowId || "unknown"));
            core.setOutput("source_run_branch", String(resolvedRunMeta.headBranch));
            core.setOutput("source_run_head_sha", sourceHeadShaShort);
            core.setOutput("source_run_conclusion", String(resolvedRunMeta.conclusion || ""));
            core.setOutput("source_run_updated_at", new Date(updatedAtMs).toISOString());
            core.setOutput("source_run_age_hours", String(runAgeHoursRounded));
            core.setOutput("max_source_run_age_hours", String(maxSourceRunAgeHours));
            core.setOutput("allow_any_source_branch", allowAnySourceBranch ? "true" : "false");
            core.info(
              `Using run ${parsedRunId}, artifact ${resolvedArtifact.name} (id=${resolvedArtifact.id}), branch=${resolvedRunMeta.headBranch}, conclusion=${resolvedRunMeta.conclusion}, age=${runAgeHoursRounded}h, headSha=${sourceHeadShaShort}, retry=${githubApiMaxAttempts}x/${githubApiRetryBackoffMs}ms, ageGuard<=${maxSourceRunAgeHours}h, allowAnySourceBranch=${allowAnySourceBranch}.`
            );

      - name: Download Source Artifact Bundle
        shell: powershell
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          function Get-HttpStatusCode([object]$ErrorRecord) {
            try {
              if ($null -eq $ErrorRecord -or $null -eq $ErrorRecord.Exception) {
                return 0
              }
              $response = $ErrorRecord.Exception.Response
              if ($null -eq $response) {
                return 0
              }
              $statusCode = $response.StatusCode
              if ($null -eq $statusCode) {
                return 0
              }
              if ($statusCode -is [int]) {
                return [int]$statusCode
              }
              if ($null -ne $statusCode.value__) {
                return [int]$statusCode.value__
              }
              return [int]$statusCode
            } catch {
              return 0
            }
          }

          function Is-RetryableStatusCode([int]$StatusCode) {
            if ($StatusCode -eq 0) {
              return $true
            }
            return @(408, 429, 500, 502, 503, 504) -contains $StatusCode
          }

          function Invoke-WithRetry(
            [string]$OperationName,
            [int]$MaxAttempts,
            [int]$BaseBackoffMs,
            [scriptblock]$Operation
          ) {
            if ($MaxAttempts -lt 1) {
              $MaxAttempts = 1
            }
            if ($BaseBackoffMs -lt 0) {
              $BaseBackoffMs = 0
            }

            $attempt = 0
            while ($attempt -lt $MaxAttempts) {
              $attempt++
              try {
                return & $Operation
              } catch {
                $statusCode = Get-HttpStatusCode -ErrorRecord $_
                $retryable = Is-RetryableStatusCode -StatusCode $statusCode
                if ($attempt -ge $MaxAttempts -or -not $retryable) {
                  throw
                }
                $delayMs = $BaseBackoffMs * $attempt
                Write-Host ("Download failed (attempt " + $attempt + "/" + $MaxAttempts + ", status=" + $statusCode + "). Retrying in " + $delayMs + "ms...")
                if ($delayMs -gt 0) {
                  Start-Sleep -Milliseconds $delayMs
                }
              }
            }

            throw ("Retry loop exited unexpectedly for operation: " + $OperationName)
          }

          $artifactIdRaw = "${{ steps.resolve_source.outputs.artifact_id }}"
          if ([string]::IsNullOrWhiteSpace($artifactIdRaw)) {
            Write-Error "Missing artifact_id from resolve step."
            exit 1
          }
          $artifactId = 0
          if (-not [long]::TryParse($artifactIdRaw, [ref]$artifactId) -or $artifactId -le 0) {
            Write-Error "Invalid artifact_id from resolve step: $artifactIdRaw"
            exit 1
          }

          $maxAttemptsRaw = "${{ steps.resolve_source.outputs.github_api_max_attempts }}"
          $backoffRaw = "${{ steps.resolve_source.outputs.github_api_retry_backoff_ms }}"
          $maxAttempts = 0
          $backoffMs = 0
          if (-not [int]::TryParse($maxAttemptsRaw, [ref]$maxAttempts) -or $maxAttempts -lt 1) {
            Write-Error "Invalid github_api_max_attempts output: $maxAttemptsRaw"
            exit 1
          }
          if (-not [int]::TryParse($backoffRaw, [ref]$backoffMs) -or $backoffMs -lt 0) {
            Write-Error "Invalid github_api_retry_backoff_ms output: $backoffRaw"
            exit 1
          }

          if ([string]::IsNullOrWhiteSpace($env:GITHUB_TOKEN)) {
            Write-Error "GITHUB_TOKEN is required for artifact download."
            exit 1
          }

          $downloadUri = "https://api.github.com/repos/${{ github.repository }}/actions/artifacts/$artifactId/zip"
          $headers = @{
            Accept                 = "application/vnd.github+json"
            Authorization          = "Bearer $env:GITHUB_TOKEN"
            "X-GitHub-Api-Version" = "2022-11-28"
          }

          $zipPath = "artifact-bundle.zip"
          if (Test-Path $zipPath) {
            Remove-Item -Path $zipPath -Force
          }
          if (Test-Path "artifact-bundle") {
            Remove-Item -Path "artifact-bundle" -Recurse -Force
          }

          Invoke-WithRetry `
            -OperationName "artifact download" `
            -MaxAttempts $maxAttempts `
            -BaseBackoffMs $backoffMs `
            -Operation {
              Invoke-WebRequest -Uri $downloadUri -Headers $headers -OutFile $zipPath -TimeoutSec 120 | Out-Null
            } | Out-Null

          Expand-Archive -Path $zipPath -DestinationPath "artifact-bundle" -Force

      - name: Prepare Local Artifact Paths
        shell: powershell
        run: |
          if (-not (Test-Path "artifact-bundle/artifacts")) {
            Write-Error "Downloaded artifact does not contain expected artifacts/ directory."
            exit 1
          }
          New-Item -Path "artifacts" -ItemType Directory -Force | Out-Null
          Copy-Item -Path "artifact-bundle/artifacts/*" -Destination "artifacts/" -Recurse -Force

      - name: Inspect Restored Artifact Set
        id: inspect_artifacts
        shell: powershell
        run: |
          $requestedPerfMode = "${{ github.event.inputs.perf_gate_mode }}"
          if ([string]::IsNullOrWhiteSpace($requestedPerfMode)) {
            $requestedPerfMode = "auto"
          }
          $requestedPerfMode = $requestedPerfMode.ToLowerInvariant()
          if (@("auto", "with_perf", "without_perf") -notcontains $requestedPerfMode) {
            Write-Error "Unsupported perf_gate_mode: $requestedPerfMode. Allowed values: auto|with_perf|without_perf."
            exit 1
          }

          $perfSummaryExists = Test-Path "artifacts/perf-load/summary.json"
          $perfPolicyExists = Test-Path "artifacts/perf-load/policy-check.json"
          $hasPerfArtifacts = $perfSummaryExists -and $perfPolicyExists

          $runWithPerf = $false
          $effectivePerfMode = "without_perf"
          switch ($requestedPerfMode) {
            "with_perf" {
              if (-not $hasPerfArtifacts) {
                Write-Error "perf_gate_mode=with_perf requires artifacts/perf-load/summary.json and artifacts/perf-load/policy-check.json."
                exit 1
              }
              $runWithPerf = $true
              $effectivePerfMode = "with_perf"
            }
            "without_perf" {
              $runWithPerf = $false
              $effectivePerfMode = "without_perf"
            }
            default {
              $runWithPerf = $hasPerfArtifacts
              $effectivePerfMode = if ($runWithPerf) { "with_perf" } else { "without_perf" }
            }
          }

          $requestedStrictRaw = "${{ github.event.inputs.strict_final_run }}"
          if ([string]::IsNullOrWhiteSpace($requestedStrictRaw)) {
            $requestedStrictRaw = "false"
          }
          $requestedStrictMode = $requestedStrictRaw.ToLowerInvariant()
          if (@("true", "false") -notcontains $requestedStrictMode) {
            Write-Error "Unsupported strict_final_run value: $requestedStrictRaw. Allowed values: true|false."
            exit 1
          }

          "requested_perf_mode=$requestedPerfMode" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "has_perf_artifacts=$($hasPerfArtifacts.ToString().ToLowerInvariant())" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "run_with_perf=$($runWithPerf.ToString().ToLowerInvariant())" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "effective_perf_mode=$effectivePerfMode" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "strict_final_run=$requestedStrictMode" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

          if ($runWithPerf) {
            Write-Host "Perf gate mode: $effectivePerfMode (requested=$requestedPerfMode, hasPerfArtifacts=$hasPerfArtifacts). strict_final_run=$requestedStrictMode."
          } else {
            Write-Host "Perf gate mode: $effectivePerfMode (requested=$requestedPerfMode, hasPerfArtifacts=$hasPerfArtifacts). strict_final_run=$requestedStrictMode. Running with -SkipPerfLoad."
          }

      - name: Build Release Evidence Report
        id: release_evidence_report
        if: always()
        shell: powershell
        run: |
          $jsonPath = "artifacts/release-evidence/report.json"
          $mdPath = "artifacts/release-evidence/report.md"
          if (Test-Path "artifacts/demo-e2e/badge-details.json") {
            powershell -NoProfile -ExecutionPolicy Bypass -File ./scripts/release-evidence-report.ps1 -BadgeDetailsPath "artifacts/demo-e2e/badge-details.json" -OutputJsonPath $jsonPath -OutputMarkdownPath $mdPath
          } else {
            Write-Host "Badge details artifact not found; skipping release evidence report."
          }
          if (Test-Path $jsonPath) {
            ("report_json_path=" + $jsonPath) | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          } else {
            ("report_json_path=") | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          }
          if (Test-Path $mdPath) {
            ("report_md_path=" + $mdPath) | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          } else {
            ("report_md_path=") | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          }

      - name: Write Source Run Manifest
        id: write_manifest
        shell: powershell
        run: |
          $manifestDir = "artifacts/release-artifact-revalidation"
          New-Item -Path $manifestDir -ItemType Directory -Force | Out-Null
          $manifestPath = Join-Path $manifestDir "source-run.json"
          $retryableStatusCodes = @(408, 429, 500, 502, 503, 504)
          $demoSummaryPath = "artifacts/demo-e2e/summary.json"
          $releaseEvidenceReportPath = "artifacts/release-evidence/report.json"
          $demoSummaryPresent = Test-Path $demoSummaryPath
          $releaseEvidenceReportPresent = Test-Path $releaseEvidenceReportPath
          $badgeDetailsPresent = $false
          $demoSummary = $null
          $releaseEvidenceReport = $null

          if ($demoSummaryPresent) {
            try {
              $demoSummary = Get-Content $demoSummaryPath -Raw | ConvertFrom-Json
            } catch {
              Write-Host ("Failed to parse demo summary for manifest evidence snapshot: " + $_.Exception.Message)
            }
          }

          if ($releaseEvidenceReportPresent) {
            try {
              $releaseEvidenceReport = Get-Content $releaseEvidenceReportPath -Raw | ConvertFrom-Json
            } catch {
              Write-Host ("Failed to parse release evidence report for manifest evidence snapshot: " + $_.Exception.Message)
            }
          }

          $operatorTurnTruncationSummaryValidated = $null
          $operatorTurnDeleteSummaryValidated = $null
          $operatorDamageControlSummaryValidated = $null
          $operatorDamageControlTotal = $null
          $operatorDamageControlLatestVerdict = $null
          $operatorDamageControlLatestSource = $null
          $operatorDamageControlLatestSeenAt = $null
          if ($null -ne $demoSummary -and $null -ne $demoSummary.kpis) {
            $operatorTurnTruncationSummaryValidated = $demoSummary.kpis.operatorTurnTruncationSummaryValidated
            $operatorTurnDeleteSummaryValidated = $demoSummary.kpis.operatorTurnDeleteSummaryValidated
            $operatorDamageControlSummaryValidated = $demoSummary.kpis.operatorDamageControlSummaryValidated
            $operatorDamageControlTotal = $demoSummary.kpis.operatorDamageControlTotal
            $operatorDamageControlLatestVerdict = $demoSummary.kpis.operatorDamageControlLatestVerdict
            $operatorDamageControlLatestSource = $demoSummary.kpis.operatorDamageControlLatestSource
            $operatorDamageControlLatestSeenAt = $demoSummary.kpis.operatorDamageControlLatestSeenAt
          }

          $badgeEvidenceOperatorDamageControlStatus = "unavailable"
          $badgeEvidenceGovernancePolicyStatus = "unavailable"
          $badgeEvidenceSkillsRegistryStatus = "unavailable"
          $badgeEvidenceDeviceNodesStatus = "unavailable"
          $badgeEvidenceDeviceNodeUpdatesStatus = "unavailable"
          $badgeEvidenceOperatorTurnTruncationStatus = "unavailable"
          $badgeEvidenceOperatorTurnDeleteStatus = "unavailable"
          if ($null -ne $releaseEvidenceReport -and $null -ne $releaseEvidenceReport.source -and $null -ne $releaseEvidenceReport.source.badgeDetailsPresent) {
            $badgeDetailsPresent = ($releaseEvidenceReport.source.badgeDetailsPresent -eq $true)
          }
          if ($null -ne $releaseEvidenceReport -and $null -ne $releaseEvidenceReport.statuses) {
            if (-not [string]::IsNullOrWhiteSpace([string]$releaseEvidenceReport.statuses.turnTruncationStatus)) {
              $badgeEvidenceOperatorTurnTruncationStatus = [string]$releaseEvidenceReport.statuses.turnTruncationStatus
            }
            if (-not [string]::IsNullOrWhiteSpace([string]$releaseEvidenceReport.statuses.turnDeleteStatus)) {
              $badgeEvidenceOperatorTurnDeleteStatus = [string]$releaseEvidenceReport.statuses.turnDeleteStatus
            }
            if (-not [string]::IsNullOrWhiteSpace([string]$releaseEvidenceReport.statuses.operatorDamageControlStatus)) {
              $badgeEvidenceOperatorDamageControlStatus = [string]$releaseEvidenceReport.statuses.operatorDamageControlStatus
            }
            if (-not [string]::IsNullOrWhiteSpace([string]$releaseEvidenceReport.statuses.governancePolicyStatus)) {
              $badgeEvidenceGovernancePolicyStatus = [string]$releaseEvidenceReport.statuses.governancePolicyStatus
            }
            if (-not [string]::IsNullOrWhiteSpace([string]$releaseEvidenceReport.statuses.skillsRegistryStatus)) {
              $badgeEvidenceSkillsRegistryStatus = [string]$releaseEvidenceReport.statuses.skillsRegistryStatus
            }
            if (-not [string]::IsNullOrWhiteSpace([string]$releaseEvidenceReport.statuses.deviceNodesStatus)) {
              $badgeEvidenceDeviceNodesStatus = [string]$releaseEvidenceReport.statuses.deviceNodesStatus
            }
            if (-not [string]::IsNullOrWhiteSpace([string]$releaseEvidenceReport.statuses.deviceNodeUpdatesStatus)) {
              $badgeEvidenceDeviceNodeUpdatesStatus = [string]$releaseEvidenceReport.statuses.deviceNodeUpdatesStatus
            }
          }

          $gateEvidenceSnapshot = [ordered]@{
            demoSummaryPresent = [bool]$demoSummaryPresent
            badgeDetailsPresent = [bool]$badgeDetailsPresent
            releaseEvidenceReportPresent = [bool]$releaseEvidenceReportPresent
            operatorTurnTruncationSummaryValidated = $operatorTurnTruncationSummaryValidated
            operatorTurnDeleteSummaryValidated = $operatorTurnDeleteSummaryValidated
            operatorDamageControlSummaryValidated = $operatorDamageControlSummaryValidated
            operatorDamageControlTotal = $operatorDamageControlTotal
            operatorDamageControlLatestVerdict = $operatorDamageControlLatestVerdict
            operatorDamageControlLatestSource = $operatorDamageControlLatestSource
            operatorDamageControlLatestSeenAt = $operatorDamageControlLatestSeenAt
            badgeEvidenceOperatorTurnTruncationStatus = $badgeEvidenceOperatorTurnTruncationStatus
            badgeEvidenceOperatorTurnDeleteStatus = $badgeEvidenceOperatorTurnDeleteStatus
            badgeEvidenceOperatorDamageControlStatus = $badgeEvidenceOperatorDamageControlStatus
            badgeEvidenceGovernancePolicyStatus = $badgeEvidenceGovernancePolicyStatus
            badgeEvidenceSkillsRegistryStatus = $badgeEvidenceSkillsRegistryStatus
            badgeEvidenceDeviceNodesStatus = $badgeEvidenceDeviceNodesStatus
            badgeEvidenceDeviceNodeUpdatesStatus = $badgeEvidenceDeviceNodeUpdatesStatus
          }

          $manifest = [ordered]@{
            schemaVersion = "1.0"
            generatedAt = [datetime]::UtcNow.ToString("o")
            repository = [ordered]@{
              name = "${{ github.repository }}"
              owner = "${{ github.repository_owner }}"
            }
            workflow = [ordered]@{
              runId = "${{ github.run_id }}"
              runAttempt = "${{ github.run_attempt }}"
            }
            sourceRun = [ordered]@{
              runId = "${{ steps.resolve_source.outputs.run_id }}"
              workflow = "${{ steps.resolve_source.outputs.source_run_workflow }}"
              branch = "${{ steps.resolve_source.outputs.source_run_branch }}"
              headSha = "${{ steps.resolve_source.outputs.source_run_head_sha }}"
              conclusion = "${{ steps.resolve_source.outputs.source_run_conclusion }}"
              updatedAt = "${{ steps.resolve_source.outputs.source_run_updated_at }}"
              ageHours = "${{ steps.resolve_source.outputs.source_run_age_hours }}"
            }
            artifact = [ordered]@{
              name = "${{ steps.resolve_source.outputs.artifact_name }}"
              id = "${{ steps.resolve_source.outputs.artifact_id }}"
            }
            sourceSelection = [ordered]@{
              allowAnySourceBranch = "${{ steps.resolve_source.outputs.allow_any_source_branch }}"
              allowedBranches = @("main", "master")
              maxSourceRunAgeHours = "${{ steps.resolve_source.outputs.max_source_run_age_hours }}"
            }
            gate = [ordered]@{
              requestedPerfMode = "${{ steps.inspect_artifacts.outputs.requested_perf_mode }}"
              effectivePerfMode = "${{ steps.inspect_artifacts.outputs.effective_perf_mode }}"
              perfArtifactsDetected = "${{ steps.inspect_artifacts.outputs.has_perf_artifacts }}"
              strictFinalRun = "${{ steps.inspect_artifacts.outputs.strict_final_run }}"
              evidenceSnapshot = $gateEvidenceSnapshot
            }
            retry = [ordered]@{
              githubApiMaxAttempts = "${{ steps.resolve_source.outputs.github_api_max_attempts }}"
              githubApiRetryBackoffMs = "${{ steps.resolve_source.outputs.github_api_retry_backoff_ms }}"
              retryableStatusCodes = $retryableStatusCodes
            }
          }

          $manifest | ConvertTo-Json -Depth 10 | Set-Content -Path $manifestPath -Encoding utf8
          $normalizedManifestPath = $manifestPath.Replace('\', '/')
          ("manifest_path=" + $normalizedManifestPath) | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          ("turn_truncation_status=" + [string]$badgeEvidenceOperatorTurnTruncationStatus) | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          ("turn_delete_status=" + [string]$badgeEvidenceOperatorTurnDeleteStatus) | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          ("operator_damage_control_status=" + [string]$badgeEvidenceOperatorDamageControlStatus) | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          ("governance_policy_status=" + [string]$badgeEvidenceGovernancePolicyStatus) | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          ("skills_registry_status=" + [string]$badgeEvidenceSkillsRegistryStatus) | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          ("device_nodes_status=" + [string]$badgeEvidenceDeviceNodesStatus) | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          ("device_node_updates_status=" + [string]$badgeEvidenceDeviceNodeUpdatesStatus) | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          Write-Host ("Source run manifest written: " + $manifestPath)

      - name: Run Artifact-Only Release Revalidation (With Perf Artifacts, Standard)
        if: steps.inspect_artifacts.outputs.run_with_perf == 'true' && steps.inspect_artifacts.outputs.strict_final_run != 'true'
        run: npm run verify:release:artifact-only
        shell: powershell

      - name: Run Artifact-Only Release Revalidation (With Perf Artifacts, Strict)
        if: steps.inspect_artifacts.outputs.run_with_perf == 'true' && steps.inspect_artifacts.outputs.strict_final_run == 'true'
        run: >
          powershell -NoProfile -ExecutionPolicy Bypass -File ./scripts/release-readiness.ps1
          -SkipBuild -SkipUnitTests -SkipMonitoringTemplates -SkipProfileSmoke -SkipDemoE2E -SkipPolicy -SkipBadge -SkipPerfRun -StrictFinalRun
        shell: powershell

      - name: Run Artifact-Only Release Revalidation (No Perf Artifacts, Standard)
        if: steps.inspect_artifacts.outputs.run_with_perf != 'true' && steps.inspect_artifacts.outputs.strict_final_run != 'true'
        run: >
          powershell -NoProfile -ExecutionPolicy Bypass -File ./scripts/release-readiness.ps1
          -SkipBuild -SkipUnitTests -SkipMonitoringTemplates -SkipProfileSmoke -SkipDemoE2E -SkipPolicy -SkipBadge -SkipPerfLoad -SkipPerfRun
        shell: powershell

      - name: Run Artifact-Only Release Revalidation (No Perf Artifacts, Strict)
        if: steps.inspect_artifacts.outputs.run_with_perf != 'true' && steps.inspect_artifacts.outputs.strict_final_run == 'true'
        run: >
          powershell -NoProfile -ExecutionPolicy Bypass -File ./scripts/release-readiness.ps1
          -SkipBuild -SkipUnitTests -SkipMonitoringTemplates -SkipProfileSmoke -SkipDemoE2E -SkipPolicy -SkipBadge -SkipPerfLoad -SkipPerfRun -StrictFinalRun
        shell: powershell

      - name: Publish Artifact Revalidation Summary
        if: always()
        shell: powershell
        run: |
          ("Source run id: ${{ steps.resolve_source.outputs.run_id }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Source run workflow: ${{ steps.resolve_source.outputs.source_run_workflow }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Source run branch: ${{ steps.resolve_source.outputs.source_run_branch }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Source run conclusion: ${{ steps.resolve_source.outputs.source_run_conclusion }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Source run head sha: ${{ steps.resolve_source.outputs.source_run_head_sha }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Source run updated at: ${{ steps.resolve_source.outputs.source_run_updated_at }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Source run age hours: ${{ steps.resolve_source.outputs.source_run_age_hours }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Artifact bundle: ${{ steps.resolve_source.outputs.artifact_name }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Requested perf mode: ${{ steps.inspect_artifacts.outputs.requested_perf_mode }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Strict final run: ${{ steps.inspect_artifacts.outputs.strict_final_run }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Allow any source branch: ${{ steps.resolve_source.outputs.allow_any_source_branch }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Max source run age hours: ${{ steps.resolve_source.outputs.max_source_run_age_hours }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("GitHub API retry attempts: ${{ steps.resolve_source.outputs.github_api_max_attempts }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("GitHub API retry backoff ms: ${{ steps.resolve_source.outputs.github_api_retry_backoff_ms }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Perf artifacts detected: ${{ steps.inspect_artifacts.outputs.has_perf_artifacts }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Effective perf mode: ${{ steps.inspect_artifacts.outputs.effective_perf_mode }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Turn-truncation status (badge evidence): ${{ steps.write_manifest.outputs.turn_truncation_status }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Turn-delete status (badge evidence): ${{ steps.write_manifest.outputs.turn_delete_status }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Operator damage-control status (badge evidence): ${{ steps.write_manifest.outputs.operator_damage_control_status }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Governance policy status (badge evidence): ${{ steps.write_manifest.outputs.governance_policy_status }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Skills registry status (badge evidence): ${{ steps.write_manifest.outputs.skills_registry_status }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Device-nodes status (badge evidence): ${{ steps.write_manifest.outputs.device_nodes_status }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Device-node-updates status (badge evidence): ${{ steps.write_manifest.outputs.device_node_updates_status }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Release evidence report JSON: ${{ steps.release_evidence_report.outputs.report_json_path }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Release evidence report Markdown: ${{ steps.release_evidence_report.outputs.report_md_path }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          ("Source run manifest: ${{ steps.write_manifest.outputs.manifest_path }}") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          if (Test-Path "artifacts/release-evidence/report.md") {
            "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
            Get-Content "artifacts/release-evidence/report.md" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          }
          if (Test-Path "artifacts/demo-e2e/summary.md") {
            "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
            Get-Content "artifacts/demo-e2e/summary.md" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          }
          if (Test-Path "artifacts/demo-e2e/policy-check.md") {
            "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
            Get-Content "artifacts/demo-e2e/policy-check.md" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          }
          if (Test-Path "artifacts/perf-load/policy-check.md") {
            "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
            Get-Content "artifacts/perf-load/policy-check.md" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          }

      - name: Upload Revalidation Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: release-artifact-revalidation-artifacts
          path: |
            artifacts/demo-e2e/summary.json
            artifacts/demo-e2e/summary.md
            artifacts/demo-e2e/policy-check.md
            artifacts/demo-e2e/policy-check.json
            artifacts/demo-e2e/badge.json
            artifacts/demo-e2e/badge-details.json
            artifacts/perf-load/summary.json
            artifacts/perf-load/summary.md
            artifacts/perf-load/policy-check.json
            artifacts/perf-load/policy-check.md
            artifacts/release-evidence/report.json
            artifacts/release-evidence/report.md
            artifacts/release-artifact-revalidation/source-run.json
          if-no-files-found: warn
